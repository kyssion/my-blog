# 设计的模式在实际场景中的应用

说这个事情的原因是因为之前比较迷信设计模式的， 喜欢去做一定的抽象

但是实际的项目运用场景的时候其实设计模式的应用还是比较少的， 更对的是抽象的方法。

这里从设计模式出发， 归纳一下抽象代码的基本方法和逻辑

# 抽象的时候要把细化功能 （最小单一原则）

举个例子 ， 我们要抽象一个功能是打电话 ， 打电话的具体能力包括 ， 拨通电话，开始通话 ， 结束对话

我们抽象java的时候本能的想可以进行这样的抽象

```java
class Phone {
    // 拨通电话
    public void call(){}

    // 通话中
    public void talk(){}
    // 结束对话
    public void end(){}
}
```

但是这种其实不好的， 我们没有抽象到跟家具体的细节上 。 比如说， 打电话其实对应计算机而言是协议开始， 而结束对话对应的功能是协议关闭 ， 而通过中对应的是数据传输 。 所以我们可以通过这种方法在进行抽象


```java

interface PhoneAgreement{
    // 开启通信管道
    public void open();

    // 关闭通信管道
    public void close();
}

interface PhoneMessage{
    // 通话中
    void tale()
}

class PhoneV2 implements PhoneAgreement, PhoneMessage{

    @Override
    public void open() {

    }

    @Override
    public void close() {

    }

    @Override
    public void tale() {

    }
}
```

> 其实这个比较依赖经验程度的，具体的拆分的判断是依赖于我们自己， 但是有一个核心点就是要保证`最小单一原则` ， 尽可能的归纳和细化能力 ， 这就要求我们写代码的时候需要做好前期规划和准备


# 合理使用继承 - 里氏替换原则

这个就不需要延伸了 ， 现在的编程语言基本上都保持了这个属性 ， 包括`继承/多态/范型`的能力。

> 我对于这个的理解其实有两个方面 1. 尽可能保持功能的唯一和确定性-一种类型的方法或者对象， 具备相同的能力 2. 尽可能保持编写代码的唯一和确定性-对统一种方法和类型操作的流程是相同的， 只不过不同的类型之间可能有删减或者增加 3. 尽可能保持心智理解上唯一性和确定性 - 针对与理解，系统功能的使用上接口的类型/对象拥有的属性都是相同的

# 依赖隔离原则

我们在实现类的时候尽可能不要做到直接引用， 这样的方法会导致抽象的层级和能力不够后续维护成本过高 ， 举个例子

```java
interface ICar{}

class CarFengtian implements ICar{}
class CarBenchi implements  ICar{}

class Driver{
    public void Drive(ICar car){}
}

class Run{
    public static void main(String[] args) {
        Driver driver = new Driver();
        ICar car1 = new CarBenchi();
        ICar car2 = new CarFengtian();
        driver.Drive(car1);
        driver.Drive(car2);
    }
}
```

注意这里： 实现Driver类的时候不要写入driver实现类， 而是要写入接口

# 保持异议 - 接口独立性

有些资料现实设计接口的时候还需要一种特殊的方法，需要对功能进行接口抽象， 引用的不是具体的类而是抽象的方法

举个例子： 比如一个搜索工具搜索书籍数据有很多类型， 不同类型的展示方法需要单独抽象成接口来使用

没写完再补充