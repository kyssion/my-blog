# 1. golang  编译器相关的处理逻辑 -

# 2. golang 编译器优化

## 1. 函数内连

golang 会对简单的函数进行内连（没有复杂语句的情况下 ， for range go select 递归函数或者复杂函数）

如果在函数前有注释 // go: noinline 表示默认不进行内连 , 或者编译的时候使用 -l 参数

```golang

func test(){}
```

> 引申 ： 打印内连信息的方法可以在编译的时候增加 -m = 2 的标记

## 2. 逃逸分析

逃逸分析是golang 重要的优化， 用户标识变量内存被分配在栈区还是堆区

在传统的c/c++ 中 ， 如果返回一个栈上的对象指针，会导致函数执行完成线程被回收之后，对象被释放

### 2.1 golang 中栈堆分配原则

a. 指向栈上的对象指针不能被存储到堆中
b. 指向栈上对象的指针不能超过真对象的神明周期

> 具体的分析策略待补充

## 3. 闭包重写

简单来说， 闭包如果调用了一次 ， 就是被初始化成一个简单函数 ， 如果多次调用或者后续调用，就会被创建闭包对象。

闭包中的值： 如果变量占用空间小于 2×sizeof(int) -> 会在内部创建局部变量来产生这个变量。 如果是通过指针或者值引用但是占用空间大，那么捕获的变量（var）将会转化成指针类型 &var。

## 4. 遍历函数

闭包重写之后需要变量函数， 会对函数中的一些表达式操作转化成运行时函数, 比如 new 和map

```golang
map -> mapaccess2_fast64()
new -> 如果有逃逸 ： newObject() 没有逃逸 new()
```

这个过程可能还会进行重排序等