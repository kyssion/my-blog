# 框架的核心思路

1. node 构成整个页面的布局. 
2. 做一个数据域的概念 -> 在一定范围内, 一个组件可以设置绑定一个数据块 , 全局所有的事件都可以某个对数据块进行修改和便捷 ,数据块负责 监听数据的变化和重新触发渲染组件
3. 做一个事件集合 -> 
    标记组件上监听的事件 , 时间会调用对应的数据数据域 -> 数据域会调用对应的组件重新渲染 . 
    事件的分类 -> 用户触发事件(js 原生事件)
    组件自触发事件 -> 组件自己调用 + 定时任务等 . 

# 细化 :

1. 数据域部分设计 :
达成的目标 : 
1. 可以监控数据变化 . diff 数据变化 ->
2. 数据绑定 -> 数据域中的需要记录数据域中数据字段


父数据域 -> 子数据域 

{
    "name":{
        "id":1234
    }
}


-> 组件要分 数据组件和布局组件 
布局组件是数据的便捷 , 不会有数据相关的操作 , 只跟布局有关系 , 布局组件会承载所有下游数据组件的数据. 
数据组件的数据依赖于布局组件 , 如果数据组件中的数据发生变化, 会向上遍历到最近的布局组件更新数据 . 


需要记录 组件的-> 数据的映射 -> 数据-组件的映射  所以 , 布局组件承载原始数据 , 还需要承载映射数据 . 
因为数据还会变化渲染 , 所以布局组件还需要有下游所有组件的渲染的函数, 
而且布局组件本身就有渲染能力所有布局组件还需要暴露渲染函数 . 渲染的逻辑就是diff 数据然后渲染 . 

0 -> 1
{
    "data": {}
    "date_type": root
    "data":name[];
    "date_type": child -> 表示当前的数据是从父元素继承
}
  -> 2 

数据域 0-0-1

子组件 0-0-1-0 

组件ID : 0-0-1
子组件 ID 0-0-1-0

结构设计




设计思路 :

数据域: => 用于圈定一个范围 ,在这个范围中 , 所有的组件都可以访问到数据域中的数据 . 
组件 : 对应页面的真正的dom 负责渲染页面
事件 : 页面中所有的动作都集成在事件中 , 整个流程就是  事件 -> 修改数据域数据 -> 修改组件信息  

# 数据域 规则 : 
1. 一个数据局域是一个json 对象 比如:
{
    name:123
}
2. 数据域中每一个数据都是和一个组件绑定的. 也就是说组件的数据来源就是一个数据域 ,  组件和事件映射是双向的 . 
{
    "组件ID":"取数表达式" -> 取数表达是就是获取数据的方法 , 就是数据的路径 比如 , name.age[123], 表示的就是获取 对象或者map 中的name字段的age数组的第123 号.
}
,
{
    "name.age[123]" : list ("组件ID")
}
组件和数据双向绑定 , 就会数据更新快速找到需要变化的组件  , 组件可以快速的获取到数据 . 
3. 一个组件只能绑定一个数据来源, 但是一个数据源可以对应多个组件 => 这里是防止状态不一致导致征用, 比如A组件可以同时获取 1 和 2 数据源的数据, 这种情况下就会发生状态不确定的问题 .  
这个逻辑就是 , 组件修改的数据来源只能有一个, 但是一个数据来源可以修改多个组件
4. 数据与的可见性 . =>
其实数据域相当于组件的一个属性 . 只要可以获取到组件 , 就能获取到这个组件所处的数据域和对应的取数逻辑, 通过这个就可以获取到数据信息 . 
也就是说, 对于任意一个组件都可以随意地方位任意一个组件的数据 . 
5. 数据域边界问题 => 为啥要有数据域. 主要是为了分装和可控性. 
比如 我封装了一个表单组件 => 外部在调用的时候 , 我其实不希望直接挂载在外部的数据域中(可能会造成数据污染).所以是用数据域 . 