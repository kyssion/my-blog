
1. base :
要有布局 , 要有事件管理.
事件会触发布局变动 . 
组件 : 
 - 数据渲染的布局 .
    - css 样式-动画  数据决定 . 
    - dom 结构
 - 逻辑操作 : 事件


// dom配置逻辑
{
    "id":在同级组件树下的唯一ID- 由框架生成,
    "name": 名称,
    "type": dom类型,
    "dataMap": -> 记录子组件和数据的绑定关系. 
    "render":-> 记录当前组件数据和dom 的绑定关系
    "style"  :-> 记录当前组件样式(动画)绑定关系
    "event" :-> 记录当前组件和事件的绑定关系,
    "path": -> dom节点的路径
}

todo : 需要编写一个映射逻辑, 当前的组件的数据和子组件绑定关系 . 


父元素负责数据分发 , 调用子元素的render 重新渲染数据 . 
父元素需要记录上一次数据的分布情况 , diff 下一次数据的变化 , 调用资源的变化. 


事件触发 -> 定位到组件 -> 组件触发数据diff , 
        

子组件数据 : 0:0:0:1 -> 123
父组件 0:0:0 -> {
    name:123
}

0:0:0:1-> name 



核心需要解决的一个问题 , 就是数据绑定 . 

子组件数据变化需要让整个链路上有绑定的数据的父元素数据需要重新设置 . 
父组件数据变化需要让子组件的数据同时变化. 

所以一个组件需要 :
1. 单向传递 . 
   子组件 :=> 0:0:0:1-> name 绑定数据 -> 全局记录数据的绑定情况 0:0:0:1(组件ID) -> name :=> 通过父组件的什么数据获取到的 . 
2. 反向传递 :=> 事件会触发数据修改 . 


算法 , 构建一个全局的数据绑定节点和数据的映射关系 , 
0:0:0:1 -> xxxx
一个构建全局数据获取的路径是啥 > 

0:0:0:1 -> name => 表示是从父元素的xxx获取的数据 . 支持表达式 , all 表示全部父元素 . 

1. 父元素数据修改 , 遍历所有的数据节点 , 变更所有的数据节点 . 
2. 子元素修改 , 反向回扫所有数据. 
   






- 框架的数据结构 ;

1. ID 体系 , 基于配置文件的dom 节点构建编号 , 深度表示层级结构  , 0-0-0-1: 这种东西
2. 数据绑定的方法 . 
数据结构 {
    "0-0-0-1": {
        "type": 数据类型 0 : 继承父元素所有值,
        "type_key": "name () , name[1]",
        "data" : interface : 当前元素的值
    }
}