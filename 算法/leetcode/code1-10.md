# 1. 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例:

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

要点 : 问题转化成查表的思路

提示: 
1. 算法中的数组都是有遍历这一种特性的 , 在遍历的过程中我们可以使用set储存已经存在的数据
2. 判断当前位置为x 和 为y 只要判断之前是否存在 y-x即可
3. 其他思路 , n^2 n*logn(排序遍历法) 需要记录位置 ,  比较复杂一种新的思路

# 2 两数相加

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

一个链表基本操作,没什么好说的

# 3. 无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:
```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

这一题有意思 , 其实还是考察对数组的理解 , 数组要考虑遍历过程

第一种思路 , 不重复队列 , 指定一个map 向后遍历,进一个数字如果这个数字在之前存在 , 前指针就向后移动

第二种思路 , 其实我们只关心当前位置是否在之前出现过 , 如果出现过 , 修正长度为出现位置+1 到当前位置

# 寻找有序数组的中位数

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:
```
nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```

这个题目真的很经典 , 在计算机中有一种很重要的思维就是将问题分解

解法1. 使用二分不停的将这个问题k变小 , 首先获取两个数组中间的值 , 比较大小,小的那个肯定是在中位数的 然后计算 k-小的长度的那个
解法2. 在1 中找是否有满足的为前k个的没有再从2中找

解法1 使用的思维是化简法  ,  解法2 是寻找关键点



